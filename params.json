{"name":"Innav","tagline":"Indoor Navigation Sandbox. Please read README before trying out demo. Demo:","body":"Indoor navigation sandbox\r\n===============\r\n\r\nThis is a web application to simulate indoor navigation schemes with beacons on a graph-based system. Features include node graph editing, graph path-finding & navigation, signal & sensor simulation, locationing simulation.\r\n\r\nThis tool is very prototypic, so please open your browser console to see more messages displayed by the sandbox.\r\n\r\n##### Table of Contents  \r\n* [Features](#features)  \r\n* [Methods of simulation](#methods-of-simulation)\r\n* [File format](#file-format)\r\n\r\nFeatures\r\n---------------\r\nThe sandbox works by enabling once at a time of the various modes to either edit the graph or simulate a navigation.\r\n* Editing:\r\n    * ```v``` or ```p```: add a new node.\r\n        * Physical node is used to represent actual hardware nodes, where virtual node is for arbitrary nodes of the graph.\r\n        * Left-click to place a node on the graph.\r\n    * ```e```: add a new edge.\r\n        * Left-click on two nodes subsequently to create an edge.\r\n        * You cannot create a loop by clicking the same node twice.\r\n    * ```x```: delete an element.\r\n        * Left-click to delete either a node or an edge.\r\n    * ```m```: move a node.\r\n        * Left-click on a node to pick it up, and left-click again to drop it on the new location.\r\n* Simulation:\r\n    * ```f```: find the shortest path between two nodes.\r\n        * No path is created if the nodes are disconnected.\r\n        * Left-click on two nodes subsequently to find the path.\r\n    * ```l```: locate the user.\r\n        * User actual is displayed as bigger red triangle.\r\n        * User accuracy is displayed as smaller orange triangle.\r\n        * Use ```WASD``` to move user actual.\r\n        * Use ```QR``` to rotate user actual.\r\n    * ```n```: on top of locationing, it finds the path to a node and displays the navigation w.r.t the user orientation.\r\n        * Left-click on a node to set it as destination. Clicking other parts of the graph will set the nearest node as destination.\r\n* ```c```: turn off all modes\r\n    * This clears out the mouse from all modes.\r\n    * It will not stop an ongoing simulation.\r\n\r\nMethods of simulation\r\n---------------\r\n* Simulating signals\r\n    * There are no actual signal emitters. In other words, the sensoring is not event-based. It is not necessary to have an event-based model for simulating signal emitting and sensoring since we want to keep the sampling at its own pace, without generating useless data in between each sampling.\r\n    * The sandbox simply keeps the readings of sources for later calculation.\r\n    * The sandbox has a scheduled task that counts the distances of all signal sources except those outside a certain bound. The bound is arbitrary, but should be the distance where beacon signal are unreceivable (in reality).\r\n    * The task will then add noise to the distance \"actual\", which is generated by a gaussian function. The variance of the function is determined by the x-axis inverse of intensity fall-off function in \"inverse-squared\" form. As a result, the further of a signal source, the larger the noise distribution, hence the less the accuracy.\r\n* Simulating processing readings:\r\n    * The function of noise cancelling simply returns the median of the readings of each signal source.\r\n* Simulating locationing: the sandbox finds the user location by multi-lateration of the stored readings\r\n    * If only one reading: out of luck.\r\n    * If two readings: the sandbox will notify the user to move a little bit to determine the third vector. Locationing with only two readings is badly inaccurate, but won't be way off.\r\n    * If 3+ readings: pick the nearest 3 and trilaterate.\r\n* Navigating:\r\n    * The sandbox shows navigation based on collected user accuracy and calculated path.\r\n    * User accuracy is assumed to be a unit vector, where angle is the user orientation. Path vector is simply the edge to the next node with a direction.\r\n    * The navigation, w.r.t the user, is then determined by subtracting the two vectors.\r\n\r\n\r\nFile format\r\n---------------\r\nThe application saves to and reads in a simple text file in ```JSON``` format. The structure of the object is as following:\r\n```\r\n{\r\n\t\"Building\":{\r\n\t\t\"name\":\"Awesome building\",\r\n\t\t\"id\":\"0\",\r\n\t\t\"UID\":\"1\"\r\n\t\t},\r\n\t\"Floors\":[\r\n\t\t{\r\n\t\t\t\"id\":\"0\",\r\n\t\t\t\"name\":\"Good floor\",\r\n\t\t\t\"alpha\":0,\r\n\t\t\t\"scale\":[10,1]\r\n\t\t},\r\n\t\t...\r\n\t],\r\n\t\"Nodes\":[\r\n\t\t{\r\n\t\t\t\"GID\":\"0\",\r\n\t\t\t\"Coords\":[90,100],\r\n\t\t\t\"Vectors\":[\"001\"],\r\n\t\t\t\"Type\":\"PHYSICAL_NODE\",\r\n\t\t\t\"PID\":\"0\",\r\n\t\t\t\"Floor\":\"0\"\r\n\t\t},\r\n\t\t...\r\n\t]\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}